本身不难，注意TCP特殊情况的处理：

1、client首先发出数据。在正式发出之前，需要对用户的两个特殊输入做考虑：
（1）如果输入“extit”，代表用户想退出，而并不是想给服务器发exit。
（2）如果输入为空：那么不能发送空，而要继续让用户输入，直至不为空，写成代码如下：
while True:
    input_data=input()
    if not input_data:
        continue
   那么有个问题是： 发送空，会有什么后果？
   经过试验，现象是这样：自己send()参数为空，是可以成功发给自己的发送队列，发送队列也可以发到网络上；对方的接收缓存也可以成功收到这个空字符串，但是对方的socket读不到，也就是recv(buffer_size )一直没有执行到位,俗称“阻塞”。至于为什么是这种效果，那就要深入理解recv()的触发机制了……这里先放一放，反正现象就是这样。
   总结：自己send()参数为空，对方一直停留在recv()，自然也没有返回，于是自己的recv()也被阻塞。

2、server需要考虑：
（1）server同样不能发送空字符串，原因同上。所以如果server本意要发空字符串，则改写发送的内容为提示信息，一来避免了阻塞，二来也是给客户端提示，客户端收到后就知道自己的输入请求不到数据。（比如你请求一个不存在的网页，别人好歹给你返回404这种作为提示，而不是真的什么都不回）

注意：同样是待发送信息为空的情况，client是continue下一轮循环，让用户重新输入非空，server是改写发送信息。最终效果都是让发送非空，但处理方式不一样，这是功能决定的。

（2）server需要考虑server forever的问题：如果连接非正常中断（比如客户端异常关闭，没有经过正常的四次挥手），需要结束内层的循环，开始下一轮外层循环，以接受一个新的会话。通过在inner loop中使用try -except-break实现，利用conn不存在引发异常。如果不做异常处理，server就会挂掉。


3、编码问题
(1)注意client.recv(buffer_size)执行以后，用的是GB2312而不是utf-8解码（会出错），这是因为server处发送的就是经GB2312编码的数据。这个编码不是server加工的，而是read()函数做的。当然，如果为了保持客户端一般用utf-8解码的习惯，server可以配合修改，即把read()的结果先用GB2312解码，再用utf8编码，最后再发送。
(2) buffer_size的大小很关键，这里是1024。中途我做了几次试验，将其改小，设为1,2，4,8等，都会报错。这是因为在GB2312的字符集里，一个汉字是2个字节，所以如果内容全是汉字，只有2的倍数个字节读取，不会有任何问题。但是这里会出现半角的空格，也占1byte，这种就会引起错位：虽然每次读双数个字节，但可能刚好把汉字的高/低拆成两次的头和尾。至于解决办法：能想到的就是buffer_size尽量增大……但感觉依然不能避免

(3)注意到一个现象：在buffer_size很小的时候（比如，假设每次只能recv1个byte），此时你看到cliend每一轮的recv结果其实并不是针对本次send的响应了，而是前一次send的响应。